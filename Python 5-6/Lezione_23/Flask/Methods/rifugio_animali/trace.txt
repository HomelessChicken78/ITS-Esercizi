

In questo esercizio dovrai scrivere il codice per un sistema che gestisce gli animali di un rifugio e che espone alcune informazioni
e funzionalit√† tramite un‚Äôapplicazione Flask. L‚Äôobiettivo √® applicare i principi di ereditariet√† e classi astratte,
e sperimentare sia le richieste HTTP GET sia le richieste HTTP POST.
üêæ Specifiche del Problema
Classe Animal

La classe Animal rappresenta un animale generico del rifugio.
√à una classe astratta e non pu√≤ essere istanziata direttamente.

Ogni animale ha:

    un identificativo id di tipo stringa (es. "d1", "c3"),

    un nome name di tipo stringa,

    un‚Äôet√† age_years di tipo intero (anni),

    un peso weight_kg di tipo float (chilogrammi).

Metodi

    species(): metodo astratto.
    Deve essere implementato nelle sottoclassi per restituire la specie dell‚Äôanimale, ad esempio "dog" o "cat".

    daily_food_grams(): metodo astratto.
    Deve essere implementato nelle sottoclassi e deve restituire la quantit√† di cibo giornaliera raccomandata in grammi.

    info(): metodo concreto.
    Restituisce un dizionario con le informazioni principali dell‚Äôanimale, ad esempio:
     
    { "id": ..., "name": ..., "species": ..., "age_years": ..., "weight_kg": ..., # pi√π eventuali campi specifici delle sottoclassi }

    bmi_like(): metodo concreto che restituisce un valore derivato (simile a un indice di ‚Äúforma fisica‚Äù), ad esempio calcolato come:
     
    weight_kg / (age_years + 1)

    Il dettaglio della formula √® lasciato libero, l‚Äôimportante √® che sia coerente e restituisca un numero (float).

Classe Dog

La classe Dog rappresenta un cane e eredita da Animal.
Attributi aggiuntivi

    breed: razza del cane, stringa (es. "labrador"),

    is_trained: booleano che indica se il cane √® addestrato (True/False).

Metodi

    species(): restituisce la stringa "dog".

    daily_food_grams(): restituisce la quantit√† di cibo giornaliero in grammi.
    Puoi usare una formula plausibile, ad esempio:
     
    return 200 + age_years * 50

    oppure un‚Äôaltra a tua scelta, purch√© sia chiaro che il risultato rappresenta grammi di cibo al giorno.

    info(): estende il metodo della superclasse includendo anche breed e is_trained, ad esempio:
     
    base = super().info() base["breed"] = self.breed base["is_trained"] = self.is_trained return base

Classe Cat

La classe Cat rappresenta un gatto e eredita da Animal.
Attributi aggiuntivi

    indoor_only: booleano che indica se il gatto vive solo in casa (True/False),

    favorite_toy: stringa che rappresenta il gioco preferito (es. "ball", "mouse").

Metodi

    species(): restituisce la stringa "cat".

    daily_food_grams(): restituisce la quantit√† di cibo giornaliero in grammi.
    Anche qui puoi usare una formula plausibile, ad esempio:
     
    return 100 + age_years * 30

    info(): estende il metodo della superclasse includendo anche indoor_only e favorite_toy.

Classe Shelter

La classe Shelter rappresenta il contenitore principale del sistema, che gestisce tutti gli animali presenti nel rifugio.
Attributi

    animals: dizionario che associa a ogni identificativo (id) l‚Äôoggetto Animal corrispondente, ad esempio:
     
    { "d1": <Dog ...>, "c1": <Cat ...>, ... }

    adoptions (opzionale ma consigliato): struttura dati per gestire lo stato di adozione, ad esempio un dizionario:
     
    { "d1": "Mario Rossi", "c1": "Luca Bianchi" }

    dove la chiave √® l‚Äôid dell‚Äôanimale e il valore √® il nome dell‚Äôadottante.

Metodi

    add(animal): aggiunge un animale al rifugio.
    Se esiste gi√† un animale con lo stesso id, puoi decidere se sovrascriverlo o ignorare l‚Äôoperazione 
    (nel contesto dell‚Äôesercizio √® sufficiente una scelta semplice e documentata nei commenti).

    get(animal_id): restituisce l‚Äôoggetto Animal corrispondente all‚ÄôID specificato oppure None se non esiste.

    list_all(): restituisce una lista di tutte le istanze di Animal presenti nel rifugio
    (puoi decidere se restituire direttamente gli oggetti o piuttosto una lista di dizionari generati con info()).

    is_adopted(animal_id): restituisce True/False a seconda che l‚Äôanimale risulti adottato nella struttura adoptions.

    set_adopted(animal_id, adopter_name): registra l‚Äôadozione per un dato animale, salvando il nome dell‚Äôadottante.

Nel codice principale dovr√† essere creato un rifugio e dovranno essere creati almeno due animali,
uno di tipo Dog e uno di tipo Cat, che saranno aggiunti al rifugio prima di avviare l‚Äôapp Flask.
Applicazione Flask

Crea un‚Äôapplicazione Flask che esponga alcune route GET per consultare i dati del rifugio e alcune route POST per modificare lo stato
(ad esempio aggiungere animali e registrare adozioni).
Le funzioni delle route devono restituire oggetti JSON (non stringhe semplici).
Route GET richieste
1. GET /

Restituisce un JSON con:

    una breve descrizione del servizio, ad esempio:
     
    { "message": "Welcome to Animal Shelter API" }

    alcuni link testuali che indicano le altre route disponibili, ad esempio:

        /animals

        /animals/d1

        /animals/d1/food

        /animals/d1/adoption

    Questi link devono essere generati dinamicamente con url_for() e poi inseriti nel JSON, ad esempio:
     
    { "message": "...", "links": { "list_animals": url_for("list_animals"), "sample_dog": url_for("get_animal", animal_id="d1"), ... } }

2. GET /animals

Restituisce un JSON con la lista degli animali presenti nel rifugio.

Ogni elemento della lista pu√≤ essere:

    una stringa descrittiva, ad esempio
    "d1 - Rex (dog) - 2 years - 18.5kg",

    oppure

    un dizionario con i campi principali dell‚Äôanimale (quelli restituiti da info()).

La scelta √® libera, ma deve essere coerente in tutto il programma (se scegli la rappresentazione come dizionario, usala ovunque per le liste).
3. GET /animals/<animal_id>

Restituisce un JSON con un solo elemento che rappresenta i dettagli dell‚Äôanimale con l‚ÄôID specificato.

Ad esempio:
{ "id": "d1", "name": "Rex", "species": "dog", "age_years": 2, "weight_kg": 18.5, "breed": "border collie", "is_trained": true }

Se l‚Äôanimale non esiste, la route dovrebbe restituire un JSON di errore (es. {"error": "Animal not found"}) con status code appropriato (ad esempio 404).
4. GET /animals/<animal_id>/food

Restituisce un JSON con le informazioni sul cibo giornaliero stimato per l‚Äôanimale specificato.

L‚Äôoutput pu√≤ essere, ad esempio:
{ "id": "d1", "daily_food_grams": 350 }

oppure una struttura pi√π ricca a tua scelta, purch√© sia JSON.

Anche qui, se l‚Äôanimale non esiste, va gestito l‚Äôerrore.
5. GET /animals/<animal_id>/adoption

Restituisce lo stato di adozione dell‚Äôanimale specificato.

Esempi di output:

Animale non adottato:
{ "id": "d1", "adopted": false }

Animale adottato:
{ "id": "d1", "adopted": true, "adopter_name": "Mario Rossi" }
Route POST richieste

Le seguenti route servono per modificare lo stato del rifugio (aggiungere animali, registrare adozioni).
In tutte le route POST il body della richiesta deve essere in formato JSON e deve essere letto tramite request.get_json().
1. POST /animals/add

Permette di aggiungere un nuovo animale al rifugio.

Il body JSON deve contenere le informazioni necessarie per creare l‚Äôanimale e un campo che specifica il tipo, ad esempio "dog" o "cat".

Esempio per un cane:
{ "type": "dog", "id": "d3", "name": "Rex", "age_years": 2, "weight_kg": 18.5, "breed": "border collie", "is_trained": true }

Esempio per un gatto:
{ "type": "cat", "id": "c5", "name": "Micia", "age_years": 3, "weight_kg": 4.2, "indoor_only": true, "favorite_toy": "ball" }

La funzione della route deve:

    leggere il JSON dalla richiesta;

    verificare che il campo "type" sia presente e valido ("dog" o "cat");

    controllare che i campi richiesti (id, name, ecc.) siano presenti;

    creare l‚Äôistanza della sottoclasse corretta (Dog o Cat);

    aggiungere l‚Äôanimale al Shelter con shelter.add(...);

    restituire un JSON di conferma, ad esempio:
     
    { "status": "ok", "added": { "id": "d3", "species": "dog" } }

In caso di errore (id gi√† esistente, campi mancanti, tipo non riconosciuto) deve restituire un JSON di errore con uno status code adeguato (es. 400 Bad Request).
2. POST /animals/<animal_id>/adopt

Registra l‚Äôadozione di un animale.

Il body JSON deve contenere almeno il nome dell‚Äôadottante, ad esempio:
{ "adopter_name": "Mario Rossi" }

La funzione della route deve:

    verificare che l‚Äôanimale con id animal_id esista nel rifugio;

    leggere il nome dell‚Äôadottante dal JSON;

    aggiornare la struttura di adozioni del Shelter (ad esempio con shelter.set_adopted(animal_id, adopter_name));

    restituire un JSON di conferma, ad esempio:
     
    { "id": "d1", "adopted": true, "adopter_name": "Mario Rossi" }

Se l‚Äôanimale non esiste, oppure √® gi√† adottato (se vuoi gestire anche questo caso), la route deve restituire un JSON di errore
e uno status code appropriato (es. 404 o 400).
Come strutturare l‚Äôesercizio

Crea un file main.py contenente:

    le classi Animal, Dog, Cat, Shelter;

    un‚Äôistanza di Shelter popolata con almeno un cane e un gatto di esempio;

    l‚Äôapplicazione Flask con tutte le route GET e POST richieste;

    il codice per avviare l‚Äôapp (solo se vuoi usare app.run() dal file Python).

Il formato delle risposte deve essere coerente: tutte le route devono restituire oggetti JSON.
Esecuzione dell‚Äôapplicazione

Il programma pu√≤ essere eseguito in due modi:

    da riga di comando:
     
    flask --app main run --debug

    oppure direttamente nel file Python, con:
    app.run(debug=True, host="127.0.0.1", port=5000)

